# OpenAI API Key for AI-powered step interpretation
OPENAI_API_KEY=your_openai_api_key_here

# Jira Configuration (optional)
JIRA_BASE_URL=https://your-domain.atlassian.net
JIRA_EMAIL=your-email@example.com
JIRA_API_TOKEN=your_jira_api_token_here

# Server Configuration
PORT=3001



from pydantic_settings import BaseSettings
from typing import List

class Settings(BaseSettings):
    # OAuth Configuration
    CLIENT_ID: str
    CLIENT_SECRET: str
    OAUTH_TOKEN_URL: str
    API_BASE_URL: str
    
    # Server Configuration
    HOST: str = "0.0.0.0"
    PORT: int = 8000
    CORS_ORIGINS: str = "http://localhost:5173"
    
    # Browser Configuration
    HEADLESS: bool = True
    SCREENSHOT_QUALITY: int = 80
    STREAM_FPS: int = 3
    
    class Config:
        env_file = ".env"
        case_sensitive = True
    
    @property
    def cors_origins_list(self) -> List[str]:
        return [origin.strip() for origin in self.CORS_ORIGINS.split(",")]
    
    @property
    def stream_interval(self) -> float:
        return 1.0 / self.STREAM_FPS

settings = Settings()


___&____

auth.py

import httpx
from datetime import datetime, timedelta
from typing import Optional
from .config import settings

class OAuthManager:
    def __init__(self):
        self.access_token: Optional[str] = None
        self.token_expiry: Optional[datetime] = None
        self.client = httpx.AsyncClient()
    
    async def get_access_token(self) -> str:
        """Get valid access token, refresh if needed"""
        if self.access_token and self.token_expiry:
            if datetime.now() < self.token_expiry:
                return self.access_token
        
        # Request new token
        await self._refresh_token()
        return self.access_token
    
    async def _refresh_token(self):
        """Request new OAuth token from company endpoint"""
        try:
            response = await self.client.post(
                settings.OAUTH_TOKEN_URL,
                data={
                    "grant_type": "client_credentials",
                    "client_id": settings.CLIENT_ID,
                    "client_secret": settings.CLIENT_SECRET,
                }
            )
            response.raise_for_status()
            
            token_data = response.json()
            self.access_token = token_data["access_token"]
            
            # Set expiry (usually expires_in is in seconds)
            expires_in = token_data.get("expires_in", 3600)
            self.token_expiry = datetime.now() + timedelta(seconds=expires_in - 60)
            
            print(f"✅ OAuth token obtained, expires at {self.token_expiry}")
            
        except Exception as e:
            print(f"❌ OAuth token error: {e}")
            raise
    
    async def close(self):
        await self.client.aclose()

# Global OAuth manager instance
oauth_manager = OAuthManager()


__&____


from pydantic import BaseModel
from typing import List, Optional
from enum import Enum

class StepStatus(str, Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"

class TaskStep(BaseModel):
    step_number: int
    description: str
    status: StepStatus = StepStatus.PENDING

class TaskRequest(BaseModel):
    task_description: str
    steps: List[str]

class StreamMessage(BaseModel):
    type: str  # 'frame', 'step_update', 'status', 'complete', 'error'
    data: Optional[dict] = None
    timestamp: float

class StepUpdateMessage(BaseModel):
    step_number: int
    status: StepStatus
    message: str


___&____



from browser_use import Agent
import asyncio
import base64
from typing import Callable, Optional
from ..config import settings
from ..auth import oauth_manager
from ..models import StepStatus

class BrowserAutomationService:
    def __init__(self):
        self.agent: Optional[Agent] = None
        self.current_step = 0
        self.total_steps = 0
        self.is_running = False
    
    async def initialize_agent(self, task: str, steps: list):
        """Initialize browser agent with OAuth token"""
        try:
            # Get valid OAuth token
            access_token = await oauth_manager.get_access_token()
            
            # Configure agent with company API
            self.agent = Agent(
                task=task,
                browser_config={
                    'headless': settings.HEADLESS,
                },
                # Add your company's API configuration here
                llm_config={
                    'api_key': access_token,
                    'base_url': settings.API_BASE_URL,
                    # Add other model-specific configs
                }
            )
            
            self.total_steps = len(steps)
            self.current_step = 0
            self.is_running = True
            
            return True
            
        except Exception as e:
            print(f"❌ Agent initialization error: {e}")
            raise
    
    async def get_screenshot(self) -> Optional[str]:
        """Capture current browser screenshot as base64"""
        if not self.agent or not self.agent.browser:
            return None
        
        try:
            # Wait for browser to be ready
            await asyncio.sleep(0.5)
            
            page = self.agent.browser.page
            screenshot_bytes = await page.screenshot(
                type='jpeg',
                quality=settings.SCREENSHOT_QUALITY
            )
            
            screenshot_base64 = base64.b64encode(screenshot_bytes).decode('utf-8')
            return screenshot_base64
            
        except Exception as e:
            print(f"⚠️ Screenshot error: {e}")
            return None
    
    async def get_current_url(self) -> str:
        """Get current page URL"""
        if not self.agent or not self.agent.browser:
            return ""
        
        try:
            return self.agent.browser.page.url
        except:
            return ""
    
    async def run_automation(self, on_step_complete: Callable):
        """Run the automation task with step tracking"""
        try:
            # Run agent with step callbacks
            result = await self.agent.run()
            
            self.is_running = False
            return result
            
        except Exception as e:
            self.is_running = False
            raise
    
    def update_step(self, step_number: int):
        """Update current step number"""
        self.current_step = step_number
    
    async def cleanup(self):
        """Cleanup resources"""
        self.is_running = False
        if self.agent and self.agent.browser:
            try:
                await self.agent.browser.close()
            except:
                pass


____&___


import asyncio
from fastapi import WebSocket
from typing import List
import time
from ..models import StepStatus, StepUpdateMessage
from ..config import settings
from .browser_service import BrowserAutomationService

class StreamService:
    def __init__(self):
        self.active_connections: List[WebSocket] = []
    
    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)
    
    def disconnect(self, websocket: WebSocket):
        if websocket in self.active_connections:
            self.active_connections.remove(websocket)
    
    async def send_message(self, websocket: WebSocket, message_type: str, data: dict = None):
        """Send structured message to client"""
        try:
            await websocket.send_json({
                'type': message_type,
                'data': data,
                'timestamp': time.time()
            })
        except Exception as e:
            print(f"⚠️ Send error: {e}")
            self.disconnect(websocket)
    
    async def send_frame(self, websocket: WebSocket, screenshot: str, url: str):
        """Send browser frame to client"""
        await self.send_message(websocket, 'frame', {
            'screenshot': screenshot,
            'url': url
        })
    
    async def send_step_update(self, websocket: WebSocket, step_number: int, status: StepStatus, message: str):
        """Send step progress update"""
        await self.send_message(websocket, 'step_update', {
            'step_number': step_number,
            'status': status,
            'message': message
        })
    
    async def send_status(self, websocket: WebSocket, message: str):
        """Send general status message"""
        await self.send_message(websocket, 'status', {'message': message})
    
    async def send_complete(self, websocket: WebSocket, result: str):
        """Send task completion message"""
        await self.send_message(websocket, 'complete', {'result': result})
    
    async def send_error(self, websocket: WebSocket, error: str):
        """Send error message"""
        await self.send_message(websocket, 'error', {'message': error})
    
    async def stream_browser(self, websocket: WebSocket, browser_service: BrowserAutomationService, steps: list):
        """Main streaming loop"""
        try:
            # Send initial status
            await self.send_status(websocket, "Initializing browser...")
            
            # Start automation task
            automation_task = asyncio.create_task(
                self._run_automation_with_steps(websocket, browser_service, steps)
            )
            
            # Stream screenshots
            while browser_service.is_running:
                screenshot = await browser_service.get_screenshot()
                if screenshot:
                    url = await browser_service.get_current_url()
                    await self.send_frame(websocket, screenshot, url)
                
                await asyncio.sleep(settings.stream_interval)
            
            # Wait for automation to complete
            result = await automation_task
            await self.send_complete(websocket, str(result))
            
        except Exception as e:
            await self.send_error(websocket, str(e))
            raise
    
    async def _run_automation_with_steps(self, websocket: WebSocket, browser_service: BrowserAutomationService, steps: list):
        """Run automation and track steps"""
        try:
            # Simulate step tracking (browser-use doesn't expose step callbacks directly)
            # You'll need to adapt this based on how browser-use exposes progress
            
            for i, step in enumerate(steps, 1):
                await self.send_step_update(websocket, i, StepStatus.IN_PROGRESS, step)
                
                # Let the browser work (you may need to integrate this differently)
                await asyncio.sleep(2)  # Adjust based on actual step completion
                
                await self.send_step_update(websocket, i, StepStatus.COMPLETED, step)
            
            # Run the actual automation
            result = await browser_service.run_automation(
                on_step_complete=lambda step: self._on_step_complete(websocket, step)
            )
            
            return result
            
        except Exception as e:
            raise
    
    async def _on_step_complete(self, websocket: WebSocket, step_info):
        """Callback when a step completes"""
        # Handle step completion
        pass



