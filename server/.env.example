# OpenAI API Key for AI-powered step interpretation
OPENAI_API_KEY=your_openai_api_key_here

# Jira Configuration (optional)
JIRA_BASE_URL=https://your-domain.atlassian.net
JIRA_EMAIL=your-email@example.com
JIRA_API_TOKEN=your_jira_api_token_here

# Server Configuration
PORT=3001

___&___

from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
import asyncio

from .config import settings
from .auth import oauth_manager
from .models import TaskRequest
from .services.browser_service import BrowserAutomationService
from .services.stream_service import StreamService

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Startup and shutdown events"""
    # Startup
    print("üöÄ Starting Browser Automation Stream Server...")
    print(f"üì° CORS enabled for: {settings.cors_origins_list}")
    
    # Initialize OAuth token on startup
    try:
        await oauth_manager.get_access_token()
        print("‚úÖ OAuth authentication successful")
    except Exception as e:
        print(f"‚ö†Ô∏è OAuth authentication failed: {e}")
    
    yield
    
    # Shutdown
    print("üõë Shutting down server...")
    await oauth_manager.close()

app = FastAPI(
    title="Browser Automation Stream API",
    version="1.0.0",
    lifespan=lifespan
)

# CORS Configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.cors_origins_list,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Global stream service
stream_service = StreamService()

@app.get("/")
async def root():
    return {
        "message": "Browser Automation Stream API",
        "version": "1.0.0",
        "status": "running"
    }

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    try:
        # Check if OAuth token is valid
        token = await oauth_manager.get_access_token()
        return {
            "status": "healthy",
            "oauth": "connected" if token else "disconnected"
        }
    except Exception as e:
        return {
            "status": "unhealthy",
            "error": str(e)
        }

@app.websocket("/ws/browser-stream")
async def websocket_endpoint(websocket: WebSocket):
    """WebSocket endpoint for browser streaming"""
    browser_service = None
    
    try:
        # Accept connection
        await stream_service.connect(websocket)
        print("‚úÖ WebSocket connected")
        
        # Wait for task request
        data = await websocket.receive_json()
        
        if data.get('type') != 'start_task':
            await stream_service.send_error(websocket, "Invalid message type")
            return
        
        task_data = data.get('data', {})
        task_description = task_data.get('task_description', '')
        steps = task_data.get('steps', [])
        
        if not task_description or not steps:
            await stream_service.send_error(websocket, "Missing task description or steps")
            return
        
        # Initialize browser service
        browser_service = BrowserAutomationService()
        await stream_service.send_status(websocket, "Authenticating...")
        
        # Initialize agent
        await browser_service.initialize_agent(task_description, steps)
        await stream_service.send_status(websocket, "Browser initialized. Starting automation...")
        
        # Start streaming
        await stream_service.stream_browser(websocket, browser_service, steps)
        
    except WebSocketDisconnect:
        print("üîå WebSocket disconnected")
    except Exception as e:
        print(f"‚ùå WebSocket error: {e}")
        try:
            await stream_service.send_error(websocket, str(e))
        except:
            pass
    finally:
        # Cleanup
        stream_service.disconnect(websocket)
        if browser_service:
            await browser_service.cleanup()
        print("üßπ Cleanup complete")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "app.main:app",
        host=settings.HOST,
        port=settings.PORT,
        reload=True
    )


___&___

"""Services module"""
from .browser_service import BrowserAutomationService
from .stream_service import StreamService

__all__ = ['BrowserAutomationService', 'StreamService']

___&___


{
  "name": "browser-automation-ui",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "lucide-react": "^0.294.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.43",
    "@types/react-dom": "^18.2.17",
    "@vitejs/plugin-react": "^4.2.1",
    "vite": "^5.0.8"
  }
}


___&___

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    proxy: {
      '/ws': {
        target: 'ws://localhost:8000',
        ws: true
      }
    }
  }
})

___&___
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Browser Automation Stream</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>


___&___

import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './styles/App.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)


___&___


import React, { useState } from 'react';
import TaskInput from './components/TaskInput';
import BrowserViewer from './components/BrowserViewer';
import StepTracker from './components/StepTracker';
import StatusBar from './components/StatusBar';
import useBrowserStream from './hooks/useBrowserStream';

function App() {
  const [isStreaming, setIsStreaming] = useState(false);
  const {
    screenshot,
    currentUrl,
    steps,
    status,
    isConnected,
    error,
    startTask,
    disconnect
  } = useBrowserStream();

  const handleStartTask = async (taskDescription, stepsList) => {
    setIsStreaming(true);
    await startTask(taskDescription, stepsList);
  };

  const handleStop = () => {
    disconnect();
    setIsStreaming(false);
  };

  return (
    <div className="app">
      {/* Header */}
      <header className="app-header">
        <div className="header-content">
          <div className="logo-section">
            <div className="logo-icon">ü§ñ</div>
            <h1>Browser Automation Studio</h1>
          </div>
          <StatusBar status={status} isConnected={isConnected} />
        </div>
      </header>

      {/* Main Content */}
      <main className="app-main">
        <div className="content-grid">
          {/* Left Panel - Task Input */}
          <div className="left-panel">
            <TaskInput 
              onStartTask={handleStartTask} 
              isStreaming={isStreaming}
              onStop={handleStop}
            />
            
            {/* Step Tracker */}
            {steps.length > 0 && (
              <div className="step-tracker-container">
                <StepTracker steps={steps} />
              </div>
            )}
          </div>

          {/* Right Panel - Browser View */}
          <div className="right-panel">
            <BrowserViewer 
              screenshot={screenshot}
              currentUrl={currentUrl}
              isStreaming={isStreaming}
            />
          </div>
        </div>

        {/* Error Display */}
        {error && (
          <div className="error-banner">
            <span className="error-icon">‚ö†Ô∏è</span>
            <span>{error}</span>
          </div>
        )}
      </main>
    </div>
  );
}

export default App;


___&___


import React, { useState } from 'react';
import { Play, Square, Plus, Trash2 } from 'lucide-react';

function TaskInput({ onStartTask, isStreaming, onStop }) {
  const [taskDescription, setTaskDescription] = useState('');
  const [steps, setSteps] = useState(['']);

  const handleAddStep = () => {
    setSteps([...steps, '']);
  };

  const handleRemoveStep = (index) => {
    if (steps.length > 1) {
      setSteps(steps.filter((_, i) => i !== index));
    }
  };

  const handleStepChange = (index, value) => {
    const newSteps = [...steps];
    newSteps[index] = value;
    setSteps(newSteps);
  };

  const handleSubmit = () => {
    const validSteps = steps.filter(step => step.trim() !== '');
    if (taskDescription.trim() && validSteps.length > 0) {
      onStartTask(taskDescription, validSteps);
    }
  };

  const isValid = taskDescription.trim() && steps.some(step => step.trim());

  return (
    <div className="task-input-card">
      <div className="card-header">
        <h2>Configure Task</h2>
        <p className="subtitle">Define your automation workflow</p>
      </div>

      <div className="card-body">
        {/* Task Description */}
        <div className="form-group">
          <label htmlFor="task-description">Task Description</label>
          <textarea
            id="task-description"
            className="task-textarea"
            placeholder="Describe what you want to automate (e.g., Search for React documentation and save the first 3 results)"
            value={taskDescription}
            onChange={(e) => setTaskDescription(e.target.value)}
            disabled={isStreaming}
            rows={3}
          />
        </div>

        {/* Steps */}
        <div className="form-group">
          <div className="label-with-action">
            <label>Steps</label>
            <button 
              className="btn-icon" 
              onClick={handleAddStep}
              disabled={isStreaming}
              title="Add step"
            >
              <Plus size={16} />
            </button>
          </div>
          
          <div className="steps-list">
            {steps.map((step, index) => (
              <div key={index} className="step-input-row">
                <span className="step-number">{index + 1}</span>
                <input
                  type="text"
                  className="step-input"
                  placeholder={`Step ${index + 1} (e.g., Navigate to Google)`}
                  value={step}
                  onChange={(e) => handleStepChange(index, e.target.value)}
                  disabled={isStreaming}
                />
                {steps.length > 1 && (
                  <button
                    className="btn-icon btn-danger"
                    onClick={() => handleRemoveStep(index)}
                    disabled={isStreaming}
                    title="Remove step"
                  >
                    <Trash2 size={16} />
                  </button>
                )}
              </div>
            ))}
          </div>
        </div>

        {/* Action Buttons */}
        <div className="action-buttons">
          {!isStreaming ? (
            <button 
              className="btn-primary btn-large"
              onClick={handleSubmit}
              disabled={!isValid}
            >
              <Play size={20} />
              <span>Start Automation</span>
            </button>
          ) : (
            <button 
              className="btn-danger btn-large"
              onClick={onStop}
            >
              <Square size={20} />
              <span>Stop</span>
            </button>
          )}
        </div>
      </div>
    </div>
  );
}

export default TaskInput;



___&___



import React from 'react';
import { Monitor, Globe } from 'lucide-react';

function BrowserViewer({ screenshot, currentUrl, isStreaming }) {
  return (
    <div className="browser-viewer-card">
      <div className="card-header">
        <div className="header-title">
          <Monitor size={20} />
          <h2>Live Browser View</h2>
        </div>
        {currentUrl && (
          <div className="url-bar">
            <Globe size={14} />
            <span className="url-text">{currentUrl}</span>
          </div>
        )}
      </div>

      <div className="browser-viewport">
        {screenshot ? (
          <img 
            src={`data:image/jpeg;base64,${screenshot}`}
            alt="Browser view"
            className="browser-screenshot"
          />
        ) : (
          <div className="browser-placeholder">
            {isStreaming ? (
              <>
                <div className="spinner"></div>
                <p>Initializing browser...</p>
              </>
            ) : (
              <>
                <Monitor size={64} className="placeholder-icon" />
                <p>Start a task to see live automation</p>
              </>
            )}
          </div>
        )}
      </div>

      {isStreaming && (
        <div className="streaming-indicator">
          <div className="pulse-dot"></div>
          <span>LIVE</span>
        </div>
      )}
    </div>
  );
}

export default BrowserViewer;



____&___


import React from 'react';
import { Check, Loader, Circle, AlertCircle } from 'lucide-react';

function StepTracker({ steps }) {
  const getStepIcon = (status) => {
    switch (status) {
      case 'completed':
        return <Check size={16} className="step-icon-completed" />;
      case 'in_progress':
        return <Loader size={16} className="step-icon-progress spin" />;
      case 'failed':
        return <AlertCircle size={16} className="step-icon-failed" />;
      default:
        return <Circle size={16} className="step-icon-pending" />;
    }
  };

  const getStepClass = (status) => {
    return `step-item step-${status}`;
  };

  return (
    <div className="step-tracker-card">
      <div className="card-header">
        <h3>Progress Tracker</h3>
        <span className="steps-count">
          {steps.filter(s => s.status === 'completed').length} / {steps.length} completed
        </span>
      </div>

      <div className="steps-timeline">
        {steps.map((step, index) => (
          <div key={index} className={getStepClass(step.status)}>
            <div className="step-marker">
              {getStepIcon(step.status)}
            </div>
            <div className="step-content">
              <div className="step-header">
                <span className="step-label">Step {step.step_number}</span>
                <span className={`step-status status-${step.status}`}>
                  {step.status.replace('_', ' ')}
                </span>
              </div>
              <p className="step-description">{step.message}</p>
            </div>
            {index < steps.length - 1 && <div className="step-connector"></div>}
          </div>
        ))}
      </div>
    </div>
  );
}

export default StepTracker;


____&___

import React from 'react';
import { Wifi, WifiOff } from 'lucide-react';

function StatusBar({ status, isConnected }) {
  return (
    <div className="status-bar">
      <div className={`connection-status ${isConnected ? 'connected' : 'disconnected'}`}>
        {isConnected ? (
          <>
            <Wifi size={16} />
            <span>Connected</span>
          </>
        ) : (
          <>
            <WifiOff size={16} />
            <span>Disconnected</span>
          </>
        )}
      </div>
      
      {status && (
        <div className="status-message">
          <span>{status}</span>
        </div>
      )}
    </div>
  );
}

export default StatusBar;


___&___



import { useState, useEffect, useRef, useCallback } from 'react';

const WS_URL = 'ws://localhost:8000/ws/browser-stream';

function useBrowserStream() {
  const [screenshot, setScreenshot] = useState(null);
  const [currentUrl, setCurrentUrl] = useState('');
  const [steps, setSteps] = useState([]);
  const [status, setStatus] = useState('');
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState(null);
  
  const wsRef = useRef(null);
  const reconnectTimeoutRef = useRef(null);

  const connect = useCallback(() => {
    try {
      const ws = new WebSocket(WS_URL);
      
      ws.onopen = () => {
        console.log('‚úÖ WebSocket connected');
        setIsConnected(true);
        setError(null);
      };
      
      ws.onmessage = (event) => {
        const message = JSON.parse(event.data);
        handleMessage(message);
      };
      
      ws.onerror = (error) => {
        console.error('‚ùå WebSocket error:', error);
        setError('Connection error occurred');
      };
      
      ws.onclose = () => {
        console.log('üîå WebSocket disconnected');
        setIsConnected(false);
        
        // Attempt reconnect after 3 seconds
        reconnectTimeoutRef.current = setTimeout(() => {
          console.log('üîÑ Attempting to reconnect...');
          connect();
        }, 3000);
      };
      
      wsRef.current = ws;
    } catch (err) {
      console.error('Failed to connect:', err);
      setError('Failed to establish connection');
    }
  }, []);

  const handleMessage = (message) => {
    const { type, data } = message;
    
    switch (type) {
      case 'frame':
        setScreenshot(data.screenshot);
        setCurrentUrl(data.url);
        break;
        
      case 'step_update':
        setSteps(prevSteps => {
          const newSteps = [...prevSteps];
          const existingIndex = newSteps.findIndex(
            s => s.step_number === data.step_number
          );
          
          if (existingIndex >= 0) {
            newSteps[existingIndex] = data;
          } else {
            newSteps.push(data);
          }
          
          return newSteps.sort((a, b) => a.step_number - b.step_number);
        });
        break;
        
      case 'status':
        setStatus(data.message);
        break;
        
      case 'complete':
        setStatus('Task completed successfully!');
        setTimeout(() => setStatus(''), 5000);
        break;
        
      case 'error':
        setError(data.message);
        setStatus('');
        break;
        
      default:
        console.log('Unknown message type:', type);
    }
  };

  const startTask = useCallback((taskDescription, stepsList) => {
    if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {
      setError('Not connected to server');
      return;
    }
    
    // Reset state
    setScreenshot(null);
    setCurrentUrl('');
    setError(null);
    setSteps(stepsList.map((step, index) => ({
      step_number: index + 1,
      message: step,
      status: 'pending'
    })));
    
    // Send task to backend
    wsRef.current.send(JSON.stringify({
      type: 'start_task',
      data: {
        task_description: taskDescription,
        steps: stepsList
      }
    }));
  }, []);

  const disconnect = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
    }
    if (wsRef.current) {
      wsRef.current.close();
      wsRef.current = null;
    }
    setIsConnected(false);
  }, []);

  useEffect(() => {
    connect();
    
    return () => {
      disconnect();
    };
  }, [connect, disconnect]);

  return {
    screenshot,
    currentUrl,
    steps,
    status,
    isConnected,
    error,
    startTask,
    disconnect
  };
}

export default useBrowserStream;


___&___

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

:root {
  --primary-color: #6366f1;
  --primary-hover: #4f46e5;
  --success-color: #10b981;
  --danger-color: #ef4444;
  --warning-color: #f59e0b;
  --bg-primary: #0f172a;
  --bg-secondary: #1e293b;
  --bg-tertiary: #334155;
  --text-primary: #f1f5f9;
  --text-secondary: #cbd5e1;
  --text-muted: #94a3b8;
  --border-color: #475569;
  --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1);
  --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
  --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1);
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  background: var(--bg-primary);
  color: var(--text-primary);
  line-height: 1.6;
  -webkit-font-smoothing: antialiased;
}

.app {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

/* Header */
.app-header {
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border-color);
  padding: 1rem 2rem;
  box-shadow: var(--shadow-md);
}

.header-content {
  max-width: 1800px;
  margin: 0 auto;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.logo-section {
  display: flex;
  align-items: center;
  gap: 1rem;
}

.logo-icon {
  font-size: 2rem;
  animation: float 3s ease-in-out infinite;
}

@keyframes float {
  0%, 100% { transform: translateY(0px); }
  50% { transform: translateY(-10px); }
}

.logo-section h1 {
  font-size: 1.5rem;
  font-weight: 700;
  background: linear-gradient(135deg, var(--primary-color), #8b5cf6);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

/* Main Content */
.app-main {
  flex: 1;
  padding: 2rem;
  max-width: 1800px;
  width: 100%;
  margin: 0 auto;
}

.content-grid {
  display: grid;
  grid-template-columns: 450px 1fr;
  gap: 2rem;
  height: calc(100vh - 140px);
}

.left-panel {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  overflow-y: auto;
}

.right-panel {
  display: flex;
  flex-direction: column;
}

/* Cards */
.task-input-card,
.browser-viewer-card,
.step-tracker-card {
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  overflow: hidden;
  box-shadow: var(--shadow-lg);
}

.card-header {
  padding: 1.5rem;
  border-bottom: 1px solid var(--border-color);
  background: rgba(99, 102, 241, 0.05);
}

.card-header h2,
.card-header h3 {
  font-size: 1.25rem;
  font-weight: 600;
  color: var(--text-primary);
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.subtitle {
  font-size: 0.875rem;
  color: var(--text-muted);
  margin-top: 0.25rem;
}

.card-body {
  padding: 1.5rem;
}

/* Form Elements */
.form-group {
  margin-bottom: 1.5rem;
}

.form-group label {
  display: block;
  font-size: 0.875rem;
  font-weight: 500;
  color: var(--text-secondary);
  margin-bottom: 0.5rem;
}

.task-textarea {
  width: 100%;
  padding: 0.75rem;
  background: var(--bg-tertiary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  color: var(--text-primary);
  font-family: inherit;
  font-size: 0.875rem;
  resize: vertical;
  transition: all 0.2s;
}

.task-textarea:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
}

.task-textarea:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Steps */
.label-with-action {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.5rem;
}

.steps-list {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.step-input-row {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.step-number {
  flex-shrink: 0;
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--primary-color);
  color: white;
  border-radius: 6px;
  font-size: 0.875rem;
  font-weight: 600;
}

.step-input {
  flex: 1;
  padding: 0.75rem;
  background: var(--bg-tertiary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  color: var(--text-primary);
  font-size: 0.875rem;
  transition: all 0.2s;
}

.step-input:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
}

.step-input:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Buttons */
.btn-primary,
.btn-danger,
.btn-icon {
  padding: 0.75rem 1.5rem;
  border: none;
  border-radius: 8px;
  font-weight: 500;
  font-size: 0.875rem;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  justify-content: center;
}

.btn-primary {
  background: var(--primary-color);
  color: white;
}

.btn-primary:hover:not(:disabled) {
  background: var(--primary-hover);
  transform: translateY(-1px);
  box-shadow: var(--shadow-md);
}

.btn-danger {
  background: var(--danger-color);
  color: white;
}

.btn-danger:hover:not(:disabled) {
  background: #dc2626;
  transform: translateY(-1px);
  box-shadow: var(--shadow-md);
}

.btn-icon {
  padding: 0.5rem;
  background: var(--bg-tertiary);
  color: var(--text-secondary);
  min-width: 36px;
  min-height: 36px;
}

.btn-icon:hover:not(:disabled) {
  background: var(--border-color);
  color: var(--text-primary);
}

.btn-icon.btn-danger {
  background: rgba(239, 68, 68, 0.1);
  color: var(--danger-color);
}

.btn-icon.btn-danger:hover:not(:disabled) {
  background: var(--danger-color);
  color: white;
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-large {
  width: 100%;
  padding: 1rem 1.5rem;
  font-size: 1rem;
}

.action-buttons {
  margin-top: 1.5rem;
}

/* Browser Viewer */
.browser-viewer-card {
  height: 100%;
  display: flex;
  flex-direction: column;
}

.header-title {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  margin-bottom: 0.75rem;
}

.url-bar {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 0.75rem;
  background: var(--bg-tertiary);
  border-radius: 6px;
  font-size: 0.875rem;
  color: var(--text-muted);
}

.url-text {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.browser-viewport {
  flex: 1;
  position: relative;
  background: var(--bg-primary);
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}

.browser-screenshot {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
  display: block;
}

.browser-placeholder {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
  color: var(--text-muted);
}

.placeholder-icon {
  opacity: 0.3;
}

.streaming-indicator {
  position: absolute;
  top: 1rem;
  right: 1rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  background: rgba(239, 68, 68, 0.9);
  color: white;
  padding: 0.5rem 1rem;
  border-radius: 20px;
  font-size: 0.75rem;
  font-weight: 600;
  letter-spacing: 0.05em;
}

.pulse-dot {
  width: 8px;
  height: 8px;
  background: white;
  border-radius: 50%;
  animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.5; transform: scale(0.8); }
}

/* Step Tracker */
.step-tracker-container {
  flex: 1;
}

.step-tracker-card {
  height: 100%;
  display: flex;
  flex-direction: column;
}

.step-tracker-card .card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.steps-count {
  font-size: 0.875rem;
  color: var(--text-muted);
  background: var(--bg-tertiary);
  padding: 0.25rem 0.75rem;
  border-radius: 12px;
}

.steps-timeline {
  padding: 1.5rem;
  overflow-y: auto;
  flex: 1;
}

.step-item {
  position: relative;
  display: flex;
  gap: 1rem;
  padding-bottom: 1.5rem;
}

.step-marker {
  flex-shrink: 0;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  background: var(--bg-tertiary);
  border: 2px solid var(--border-color);
  z-index: 1;
}

.step-connector {
  position: absolute;
  left: 15px;
  top: 32px;
  bottom: 0;
  width: 2px;
  background: var(--border-color);
}

.step-content {
  flex: 1;
  padding-top: 0.25rem;
}

.step-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.5rem;
}

.step-label {
  font-size: 0.75rem;
  font-weight: 600;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.step-status {
  font-size: 0.75rem;
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-weight: 500;
  text-transform: capitalize;
}

.status-pending {
  background: rgba(148, 163, 184, 0.1);
  color: var(--text-muted);
}

.status-in_progress {
  background: rgba(245, 158, 11, 0.1);
  color: var(--warning-color);
}

.status-completed {
  background: rgba(16, 185, 129, 0.1);
  color: var(--success-color);
}

.status-failed {
  background: rgba(239, 68, 68, 0.1);
  color: var(--danger-color);
}

.step-description {
  font-size: 0.875rem;
  color: var(--text-primary);
  line-height: 1.5;
}

/* Step Icons */
.step-icon-completed {
  color: var(--success-color);
}

.step-icon-progress {
  color: var(--warning-color);
}

.step-icon-failed {
  color: var(--danger-color);
}

.step-icon-pending {
  color: var(--text-muted);
}

.step-pending .step-marker {
  border-color: var(--border-color);
}

.step-in_progress .step-marker {
  border-color: var(--warning-color);
  background: rgba(245, 158, 11, 0.1);
}

.step-completed .step-marker {
  border-color: var(--success-color);
  background: rgba(16, 185, 129, 0.1);
}

.step-failed .step-marker {
  border-color: var(--danger-color);
  background: rgba(239, 68, 68, 0.1);
}

/* Status Bar */
.status-bar {
  display: flex;
  align-items: center;
  gap: 1.5rem;
}

.connection-status {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 1rem;
  border-radius: 20px;
  font-size: 0.875rem;
  font-weight: 500;
}

.connection-status.connected {
  background: rgba(16, 185, 129, 0.1);
  color: var(--success-color);
}

.connection-status.disconnected {
  background: rgba(239, 68, 68, 0.1);
  color: var(--danger-color);
}

.status-message {
  font-size: 0.875rem;
  color: var(--text-secondary);
}

/* Error Banner */
.error-banner {
  position: fixed;
  bottom: 2rem;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  align-items: center;
  gap: 0.75rem;
  background: var(--danger-color);
  color: white;
  padding: 1rem 1.5rem;
  border-radius: 8px;
  box-shadow: var(--shadow-xl);
  max-width: 600px;
  z-index: 1000;
  animation: slideUp 0.3s ease-out;
}

@keyframes slideUp {
  from {
    transform: translateX(-50%) translateY(100px);
    opacity: 0;
  }
  to {
    transform: translateX(-50%) translateY(0);
    opacity: 1;
  }
}

.error-icon {
  font-size: 1.25rem;
}

/* Animations */
.spinner {
  width: 48px;
  height: 48px;
  border: 4px solid var(--border-color);
  border-top-color: var(--primary-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.spin {
  animation: spin 1s linear infinite;
}

/* Scrollbar */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: var(--bg-tertiary);
}

::-webkit-scrollbar-thumb {
  background: var(--border-color);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted);
}

/* Responsive */
@media (max-width: 1400px) {
  .content-grid {
    grid-template-columns: 400px 1fr;
  }
}

@media (max-width: 1024px) {
  .content-grid {
    grid-template-columns: 1fr;
    height: auto;
  }
  
  .left-panel {
    max-height: 600px;
  }
  
  .right-panel {
    min-height: 500px;
  }
}

@media (max-width: 768px) {
  .app-main {
    padding: 1rem;
  }
  
  .content-grid {
    gap: 1rem;
  }
  
  .app-header {
    padding: 1rem;
  }
  
  .header-content {
    flex-direction: column;
    align-items: flex-start;
    gap: 1rem;
  }
}


&___

const API_BASE_URL = 'http://localhost:8000';

export const checkHealth = async () => {
  try {
    const response = await fetch(`${API_BASE_URL}/health`);
    return await response.json();
  } catch (error) {
    console.error('Health check failed:', error);
    return null;
  }
};

export default {
  checkHealth
};


___&___



