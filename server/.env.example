# OpenAI API Key for AI-powered step interpretation
OPENAI_API_KEY=your_openai_api_key_here

# Jira Configuration (optional)
JIRA_BASE_URL=https://your-domain.atlassian.net
JIRA_EMAIL=your-email@example.com
JIRA_API_TOKEN=your_jira_api_token_here

# Server Configuration
PORT=3001

___&____

You are a senior browser automation engineer with 20+ years of real-world experience.

You specialize in:
- Playwright, Selenium, Puppeteer
- AI-driven browser automation (browser-use, LLM agents)
- Login automation, SSO, OAuth, CAPTCHA handling
- Secure credential handling (env vars, vaults, token reuse)
- Handling dynamic DOM, XPath/CSS breakage
- Proxy issues (407), headless vs non-headless debugging
- Performance, stability, and production-ready automation

Rules you MUST follow:
1. Always give practical, production-ready answers.
2. Prefer step-by-step explanations over theory.
3. If code is required:
   - Show minimal but complete working code
   - Explain WHY each step exists
4. Point out common mistakes and how to avoid them.
5. If multiple approaches exist:
   - Compare them
   - Recommend the BEST one for real projects
6. Assume the user is a developer working under time pressure.
7. Avoid generic AI answers. Think like a real engineer debugging a real issue.
8. Ask clarifying questions ONLY if absolutely required.

Your goal:
Help me build reliable, secure, and maintainable browser automation solutions efficiently.

_____&______

# browser_factory.py
from browser_use import Browser
import os

def create_browser(user_id: int, app_name: str, headless: bool = True):
    """
    Creates an isolated browser for a user + application
    """

    os.makedirs("storage", exist_ok=True)
    storage_path = f"storage/user_{user_id}_{app_name}.json"

    browser = Browser(
        headless=headless,
        storage_state=storage_path,
    )

    return browser, storage_path



# step_logger.py

def map_action_to_step(action: dict) -> str:
    """
    Converts BrowserUse action to human-readable step
    """
    name = action.get("name", "").lower()
    args = action.get("args", {})

    if "goto" in name:
        return f"Navigate to {args.get('url')}"
    if "click" in name:
        return "Click element"
    if "type" in name:
        return f"Type '{args.get('text')}'"
    if "scroll" in name:
        return "Scroll page"

    return f"Perform {name}"



# browser_service.py
import asyncio
from browser_use import Agent
from browser_factory import create_browser
from step_logger import map_action_to_step


class BrowserUseService:
    """
    Core BrowserUse execution service
    """

    def __init__(self, user_id: int, app_name: str):
        self.user_id = user_id
        self.app_name = app_name
        self.browser = None

    async def run_task(self, task_text: str):
        """
        Executes a natural-language task using BrowserUse
        """

        # 1. Create browser (session-aware)
        self.browser, storage_path = create_browser(
            user_id=self.user_id,
            app_name=self.app_name,
            headless=True
        )

        print(f"[INFO] Using session: {storage_path}")

        await self.browser.start()
        page = await self.browser.new_page()

        # 2. Create agent
        agent = Agent(
            task=task_text,
            browser=self.browser,
            page=page,
            max_steps=15,
            use_vision=True,
        )

        step_count = 0

        try:
            print("[INFO] Starting BrowserUse execution")

            async for event in agent.run_stream():

                if event["type"] == "action_start":
                    step_count += 1
                    step_title = map_action_to_step(event["action"])

                    print(f"STEP {step_count}: {step_title} ⏳")

                elif event["type"] == "action_end":
                    print(f"STEP {step_count}: Completed ✅")

                elif event["type"] == "error":
                    print(f"STEP {step_count}: Failed ❌")
                    print(event["error"])
                    break

            print("[INFO] Task execution completed")

        finally:
            await self.browser.close()


# run_test.py
import asyncio
from browseruse_service.browser_service import BrowserUseService

async def main():
    service = BrowserUseService(
        user_id=1,
        app_name="ABCPortal"
    )

    await service.run_task(
        "Open google.com and search for OpenAI"
    )

asyncio.run(main())



